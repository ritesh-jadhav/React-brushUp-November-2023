React.createElement => object => HtmlElement(render)

const heading = React.createElement("h1",{id: "heading"},"React element");

// JSX - Html-likely syntax that understand by JS engine  
// JSX => babel transpile it to React.createElement => ReactElement-JS Object => htmlElement(reder)

const jsxHeading = <h1 id="heading">React JSX element</h1>

const content = <p>Lorem ipsum dolor, sit amet consectetur adipisicing elit. Commodi labore nisi nobis eligendi illo ea et, dolorem voluptatum alias tempora repellat corrupti numquam officiis ipsam aliquid natus nemo dignissimos tenetur.</p>

// Functional Components 

const about = function (){
    return <h1>This is a functional component</h1>
}

const BrandTitle = () =>{
    return <div className="container">
        {about()}
        <h1 id="heading">React functional Component</h1>
        {content}
        {jsxHeading}
    </div>
}



npm -> Something that manage the dependancies


parcel -> buddler that will wrap up all the things and take that packed pakages towards the production 

# Parcel - A Beast 
    - Dev build
    - local development server 
    - HMR = Hot module replacement
    - uses File waching algorithm written for latest build in c++ 
    - Caching - Faster build (Reduces build time)
    - Tree Shaking - remove unused code
    - Image optimization 
    - compress file and optimize Bundle by removing whitespaces of all js code  
    - Code splitting
    - Consistent hashing 
    - Differential bundle (support for older browsers)
    - Beautify errors and gives diagostic of the app 


dist folder -> parcel will pack all the code inside a package and takes care it should be delivered to the development server
.parce-cache -> cache will used to reduce the build time (time gets reduce as the number of times builds)



npm install -D parcel -> -D will add the dependancies in development environment only (npm install dependancy_name will install and use the common dependancies in both development and production environment )
npx -> command to execute installed node module
npx  parcel index.html -> packe the code and deploy the file on the development server(hosting an application on server)

npx parcel build index.html -> will create a productions ready build (only core files of the application)
    dist\index.html                339 B    1.35s
    dist\index.c9074835.js     139.19 KB    734ms
    dist\index.1e2b8b93.css         65 B     60ms

# package.json
   
    "scripts": {
    "start" : "parcel index.html",  -> to start the project in development (reserved keyword for npm to start something) 
    "build" : "parcel build index.html",  -> to build production package
    "test": "jest"
  }

  PS C:\Users\Ritesh J\OneDrive\Desktop\React-brushUp November 2023> npm start

    > react@1.0.0 start
    > parcel index.html

    Server running at http://localhost:1234
    âœ¨ Built in 1.30s


  "browserlist":[       => For support older browser
    "last 2 versions",
    "fully supports es6"
  ]
==================================================================================================================================
Config Driven UI :: UI is designed in such a way that it should be configured bby the data that backend is sending.
e.g. Different zone have different offers,different cursoal,and the offers....UI can be modified based on what data we configured

2 ways of export 
  -default export -> at the end of file export default module_name_or_variable;
  -named export -> recommended to use when we have to export more than one (at the time of immport destructure and use)
  e.g. 
  
  export const swiggyCdn = "https://media-assets.swiggy.com/swiggy/image/upload/fl_lossy,f_auto,q_auto,w_660/"; //constants.js file
  import { swiggyCdn } from "../utils/constants"; // another.js file

  =================================================================================================================================


  React is faster because of the virtual dom actually for the first time when page gest loaded browser will keep the presentation of all the 
  html nodes in json or xml format. React additionally having its virtual dom and whenever any changes react virtual dom will recognise the 
  changes and updates UI accordingly. react is very fast to manage the DOM manupualtion.
  React reconciliation is nothing but the diff. algorithm that can detect the changes betn old and updated DOM re-render the component. ->same thing known as React fiber in version 16 
  React/angular and other UI framwork is meant up for config driven UI so anything changes at the data layer it can be replicated on UI fastly 
  Data layer and UI is synced and react manages the dom efficiently that makes react much more faster.

============================================================================================================================================
Hooks : hooks are at the end of day are javascript utility functions provided by React developers to enchance the superpowers of react.

useState() => A superpowerful state variable
Whenever state changes of that variable inside a component react will re-render that component using virtual dom.


Normal javascript can't make a component dynamic and can't change the content once page gets loaded. To make component dynamic and capable of
showing updated values on Ui quickly by renrendering the component react introduced state variable.  

import { useState } from "react";


const [list, setList] = useState(default_value_for_state_variable);


equivalent to =>
const ele1 = arr[0];
const ele1 = arr[1];
const test = [arr[0],arr[1]]
const {{arr[0]} ,arr[1] }  // destructuring on the fly

- How useEffect() will update the const variable or state ??
const [varaibleName, setVaribleName] = useEffect(default_value_for_const_variable)
varaibleName => name for the constant variable
setVaribleName => callback function provided by react and that will update the value process component to be re-render with updated value. 

- Whenever state updates react will trigger reconciliation cycle(component re-rendering)

- Why react is fast?
reconciliation algorithm will make react faster an it detect the chanages of virtual dom and manipulate the dom operation efficiently.
=========================================================================================================


Monlithic Vs. Microservices Application

Monolithic -> all the ui,api,db and the services are packed isnide one project and deployed to the internet.
Microservices -> Each service is written as a different project and all combines together to form an application. its also known Seperation of concerns and it follows 
single responsibilty principal and each service has its own job.

Rendering a component  ->
  - useEffect() is a js utility function and re- render the react component.
  - useEffect(){ ()=>{}, [] }  
  two args - 1. callback function : that will called by useEffect() .
           - 2. [] dependancies array : whenever the list of dependancy chanages callback will be called.

Two ways to api call 
1. as soon as page loads -> call api -> wait for the response for getting content and render the UI.
2. Render the Ui whatever we have ->  api call -> data -> re-render the UI. //gives better UX 

Shimmer UI -> show skelton while loading the page 

Conditional rerendering => rendering a component based on specific condition 

=======================================================================================================================

